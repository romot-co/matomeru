import * as vscode from 'vscode';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { DirectoryProcessingService } from '@/domain/output/DirectoryProcessingService';
import { DirectoryScanner, ScanResult } from '@/domain/files/DirectoryScanner';
import { MarkdownGenerator } from '@/domain/output/MarkdownGenerator';
import { IUIService } from '@/domain/output/UIService';
import { II18nService } from '@/i18n/I18nService';
import { IConfigurationService, Configuration } from '@/infrastructure/config/ConfigurationService';
import { IPlatformService } from '@/infrastructure/platform/PlatformService';
import { IErrorHandler } from '@/shared/errors/services/ErrorService';
import { IWorkspaceService } from '@/domain/workspace/WorkspaceService';
import { ILogger } from '@/infrastructure/logging/LoggingService';
import { IClipboardService } from '@/infrastructure/platform/ClipboardService';
import { BaseError } from '../../../shared/errors/base/BaseError';
import { UnsupportedPlatformError } from '@/shared/errors/ChatGPTErrors';
import { LogContext } from '@/infrastructure/logging/LoggingService';
import { ErrorContext } from '../../../types';
import { ScanError } from '../../../shared/errors/ScanError';

describe('DirectoryProcessingService', () => {
    let service: DirectoryProcessingService;
    let sandbox: sinon.SinonSandbox;
    let context: vscode.ExtensionContext;
    let scannerStub: sinon.SinonStubbedInstance<DirectoryScanner>;
    let markdownGeneratorStub: sinon.SinonStubbedInstance<MarkdownGenerator>;
    let uiServiceStub: sinon.SinonStubbedInstance<IUIService>;
    let i18nStub: sinon.SinonStubbedInstance<II18nService>;
    let configServiceStub: sinon.SinonStubbedInstance<IConfigurationService>;
    let platformServiceStub: sinon.SinonStubbedInstance<IPlatformService>;
    let errorHandlerStub: sinon.SinonStubbedInstance<IErrorHandler>;
    let workspaceServiceStub: sinon.SinonStubbedInstance<IWorkspaceService>;
    let loggerStub: sinon.SinonStubbedInstance<ILogger>;
    let clipboardServiceStub: sinon.SinonStubbedInstance<IClipboardService>;

    const testPath = '/test/dir';
    const scanResult: ScanResult = {
        files: [
            {
                path: 'file1.ts',
                relativePath: 'file1.ts',
                size: 100,
                content: 'content1',
                language: 'typescript'
            },
            {
                path: 'file2.ts',
                relativePath: 'file2.ts',
                size: 100,
                content: 'content2',
                language: 'typescript'
            }
        ],
        totalSize: 200
    } as any; // 型合わせのため any キャスト

    const markdown = '# Test Directory\n```typescript\n// content\n```';

    beforeEach(() => {
        sandbox = sinon.createSandbox();

        context = {
            subscriptions: [],
            extensionPath: '',
            globalState: {
                get: sandbox.stub(),
                update: sandbox.stub().resolves(),
                keys: () => []
            } as any,
            workspaceState: {} as any,
            extensionUri: vscode.Uri.file(''),
            environmentVariableCollection: {} as any,
            storageUri: vscode.Uri.file(''),
            globalStorageUri: vscode.Uri.file(''),
            logUri: vscode.Uri.file(''),
            extensionMode: vscode.ExtensionMode.Test,
            extension: {} as any,
            secrets: {} as any,
            asAbsolutePath: (p: string) => p,
            storagePath: '',
            globalStoragePath: '',
            logPath: '',
            languageModelAccessInformation: {} as any
        } as vscode.ExtensionContext;

        scannerStub = sandbox.createStubInstance(DirectoryScanner);
        markdownGeneratorStub = sandbox.createStubInstance(MarkdownGenerator);
        platformServiceStub = sandbox.createStubInstance<IPlatformService>(class implements IPlatformService {
            getFeatures() { return { canUseChatGPT: true, canUseNativeFeatures: true }; }
            openInChatGPT() { return Promise.resolve(); }
            copyToClipboard() { return Promise.resolve(); }
            checkAccessibilityPermission() { return Promise.resolve(true); }
            launchApplication() { return Promise.resolve(); }
        });
        uiServiceStub = sandbox.createStubInstance<IUIService>(class implements IUIService {
            showInformationMessage() { return Promise.resolve(); }
            showErrorMessage() { return Promise.resolve(); }
            showProgress<T>() { return Promise.resolve({} as T); }
            openTextDocument() { return Promise.resolve(); }
        });
        clipboardServiceStub = sandbox.createStubInstance<IClipboardService>(class implements IClipboardService {
            writeText() { return Promise.resolve(); }
            readText() { return Promise.resolve(''); }
        });
        workspaceServiceStub = sandbox.createStubInstance<IWorkspaceService>(class implements IWorkspaceService {
            validateWorkspacePath() { return Promise.resolve(true); }
            getWorkspacePath() { return '/test/workspace'; }
            onWorkspaceChange() { return { dispose: () => {} }; }
            getWorkspaceFolder() { return Promise.resolve({ uri: vscode.Uri.file('/test/workspace'), name: 'test', index: 0 }); }
            selectWorkspaceFolder() { return Promise.resolve({ uri: vscode.Uri.file('/test/workspace'), name: 'test', index: 0 }); }
        });
        errorHandlerStub = sandbox.createStubInstance<IErrorHandler>(class implements IErrorHandler {
            handleError() { return Promise.resolve(); }
            getErrorLogs() { return []; }
            clearErrorLogs() {}
        });
        loggerStub = sandbox.createStubInstance<ILogger>(class implements ILogger {
            info() {}
            warn() {}
            error() {}
            debug() {}
            show() {}
            dispose() {}
        });
        i18nStub = sandbox.createStubInstance<II18nService>(class implements II18nService {
            t() { return 'テスト成功'; }
            setLocale() {}
            getCurrentLocale() { return 'ja'; }
        });
        configServiceStub = sandbox.createStubInstance<IConfigurationService>(class implements IConfigurationService {
            getConfiguration(): Configuration {
                return {
                    excludePatterns: ['node_modules/**', '.git/**'],
                    maxFileSize: 1048576,
                    maxConcurrentFiles: 10,
                    defaultOutputType: 'editor' as const,
                    chatGptIntegration: true,
                    batchSize: 100,
                    chatgptBundleId: 'com.openai.chat',
                    development: {
                        mockChatGPT: true,
                        debugLogging: false,
                        disableNativeFeatures: false
                    }
                };
            }
            addChangeListener() {}
            removeChangeListener() {}
        });

        scannerStub.scan.resolves(scanResult);
        markdownGeneratorStub.generateMarkdown.resolves(markdown);
        platformServiceStub.openInChatGPT.resolves();
        platformServiceStub.getFeatures.returns({
            canUseChatGPT: true,
            canUseNativeFeatures: true
        });
        platformServiceStub.checkAccessibilityPermission.resolves(true);
        platformServiceStub.launchApplication.resolves();
        uiServiceStub.openTextDocument.resolves();
        uiServiceStub.showInformationMessage.resolves();
        clipboardServiceStub.writeText.resolves();
        workspaceServiceStub.validateWorkspacePath.resolves(true);
        i18nStub.t.returns('テスト成功');

        service = new DirectoryProcessingService(
            context,
            scannerStub,
            markdownGeneratorStub,
            uiServiceStub,
            i18nStub,
            configServiceStub,
            platformServiceStub,
            errorHandlerStub,
            workspaceServiceStub,
            loggerStub,
            clipboardServiceStub
        );
    });

    afterEach(() => {
        sandbox.restore();
    });

    describe('processDirectoryToChatGPT', () => {
        describe('正常系', () => {
            it('ディレクトリの内容をChatGPTで開く', async () => {
                await service.processDirectoryToChatGPT(testPath);

                sinon.assert.calledOnce(scannerStub.scan);
                expect(scannerStub.scan.firstCall.args[0]).to.equal(testPath);
                sinon.assert.calledOnce(markdownGeneratorStub.generateMarkdown);
                sinon.assert.calledOnce(platformServiceStub.openInChatGPT);
            });

            it('空のディレクトリを処理できる', async () => {
                const emptyResult = { files: [], totalSize: 0 };
                scannerStub.scan.resolves(emptyResult);
                const emptyMarkdown = '# Empty Directory';
                markdownGeneratorStub.generateMarkdown.resolves(emptyMarkdown);

                await service.processDirectoryToClipboard(testPath);

                sinon.assert.calledOnce(scannerStub.scan);
                expect(scannerStub.scan.firstCall.args[0]).to.equal(testPath);
                sinon.assert.calledOnce(markdownGeneratorStub.generateMarkdown);
                sinon.assert.calledOnce(clipboardServiceStub.writeText);
            });
        });

        describe('異常系', () => {
            it('プラットフォーム機能が利用できない場合はエラーを処理する', async () => {
                platformServiceStub.getFeatures.returns({
                    canUseChatGPT: false,
                    canUseNativeFeatures: false
                });

                try {
                    await service.processDirectoryToChatGPT(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(UnsupportedPlatformError);
                }
            });

            it('ディレクトリスキャンに失敗した場合はエラーを処理する', async () => {
                const error = new ScanError('スキャンエラー');
                scannerStub.scan.rejects(error);

                try {
                    await service.processDirectoryToChatGPT(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(ScanError);
                    if (err instanceof ScanError) {
                        expect(err.message).to.equal('スキャンエラー');
                    }
                }
            });

            it('Markdown生成に失敗した場合はエラーを処理する', async () => {
                const error = new BaseError('Markdown生成エラー', 'MarkdownGenerationError');
                markdownGeneratorStub.generateMarkdown.rejects(error);

                try {
                    await service.processDirectoryToChatGPT(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(BaseError);
                    if (err instanceof BaseError) {
                        expect(err.message).to.equal('Markdown生成エラー');
                    }
                }
            });

            it('ChatGPTでの表示に失敗した場合はエラーを処理する', async () => {
                const error = new BaseError('ChatGPT表示エラー', 'ChatGPTDisplayError');
                platformServiceStub.openInChatGPT.rejects(error);

                try {
                    await service.processDirectoryToChatGPT(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(BaseError);
                    if (err instanceof BaseError) {
                        expect(err.message).to.equal('ChatGPT表示エラー');
                    }
                }
            });
        });
    });

    describe('processDirectoryToEditor', () => {
        describe('正常系', () => {
            it('ディレクトリの内容をエディタで開く', async () => {
                await service.processDirectoryToEditor(testPath);

                sinon.assert.calledWith(scannerStub.scan, testPath);
                sinon.assert.calledOnce(markdownGeneratorStub.generateMarkdown);
                sinon.assert.calledOnce(uiServiceStub.openTextDocument);
            });

            it('空のディレクトリを処理できる', async () => {
                const emptyResult = { files: [], totalSize: 0 };
                scannerStub.scan.resolves(emptyResult);
                const emptyMarkdown = '# Empty Directory';
                markdownGeneratorStub.generateMarkdown.resolves(emptyMarkdown);

                await service.processDirectoryToEditor(testPath);

                sinon.assert.calledWith(scannerStub.scan, testPath);
                sinon.assert.calledOnce(markdownGeneratorStub.generateMarkdown);
                sinon.assert.calledOnce(uiServiceStub.openTextDocument);
            });
        });

        describe('異常系', () => {
            it('ディレクトリスキャンに失敗した場合はエラーを処理する', async () => {
                const error = new ScanError('スキャンエラー');
                scannerStub.scan.rejects(error);

                try {
                    await service.processDirectoryToEditor(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(ScanError);
                    expect((err as ScanError).message).to.equal('スキャンエラー');
                }
            });

            it('Markdown生成に失敗した場合はエラーを処理する', async () => {
                const error = new BaseError('Markdown生成エラー', 'MarkdownGenerationError');
                markdownGeneratorStub.generateMarkdown.rejects(error);

                try {
                    await service.processDirectoryToEditor(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(BaseError);
                    expect((err as BaseError).message).to.equal('Markdown生成エラー');
                }
            });

            it('エディタでの表示に失敗した場合はエラーを処理する', async () => {
                const error = new BaseError('エディタ表示エラー', 'EditorDisplayError');
                uiServiceStub.openTextDocument.rejects(error);

                try {
                    await service.processDirectoryToEditor(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(BaseError);
                    expect((err as BaseError).message).to.equal('エディタ表示エラー');
                }
            });
        });
    });

    describe('processDirectoryToClipboard', () => {
        describe('正常系', () => {
            it('ディレクトリの内容をクリップボードにコピーする', async () => {
                await service.processDirectoryToClipboard(testPath);

                sinon.assert.calledWith(scannerStub.scan, testPath);
                sinon.assert.calledOnce(markdownGeneratorStub.generateMarkdown);
                sinon.assert.calledOnce(clipboardServiceStub.writeText);
            });

            it('空のディレクトリを処理できる', async () => {
                const emptyResult = { files: [], totalSize: 0 };
                scannerStub.scan.resolves(emptyResult);
                const emptyMarkdown = '# Empty Directory';
                markdownGeneratorStub.generateMarkdown.resolves(emptyMarkdown);

                await service.processDirectoryToClipboard(testPath);

                sinon.assert.calledWith(scannerStub.scan, testPath);
                sinon.assert.calledOnce(markdownGeneratorStub.generateMarkdown);
                sinon.assert.calledOnce(clipboardServiceStub.writeText);
            });
        });

        describe('異常系', () => {
            it('プラットフォーム機能が利用できない場合はエラーを処理する', async () => {
                platformServiceStub.getFeatures.returns({
                    canUseChatGPT: false,
                    canUseNativeFeatures: false
                });

                try {
                    await service.processDirectoryToClipboard(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(UnsupportedPlatformError);
                }
            });

            it('ディレクトリスキャンに失敗した場合はエラーを処理する', async () => {
                const error = new ScanError('スキャンエラー');
                scannerStub.scan.rejects(error);

                try {
                    await service.processDirectoryToClipboard(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(ScanError);
                    expect((err as ScanError).message).to.equal('スキャンエラー');
                }
            });

            it('Markdown生成に失敗した場合はエラーを処理する', async () => {
                const error = new BaseError('Markdown生成エラー', 'MarkdownGenerationError');
                markdownGeneratorStub.generateMarkdown.rejects(error);

                try {
                    await service.processDirectoryToClipboard(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(BaseError);
                    expect((err as BaseError).message).to.equal('Markdown生成エラー');
                }
            });

            it('クリップボードへのコピーに失敗した場合はエラーを処理する', async () => {
                const error = new BaseError('クリップボードエラー', 'ClipboardError');
                clipboardServiceStub.writeText.rejects(error);

                try {
                    await service.processDirectoryToClipboard(testPath);
                    expect.fail('エラーが発生するはず');
                } catch (err: unknown) {
                    expect(err).to.be.instanceOf(BaseError);
                    expect((err as BaseError).message).to.equal('クリップボードエラー');
                }
            });
        });
    });
});
