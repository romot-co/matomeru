import { beforeEach, describe, expect, jest, test } from '@jest/globals';
import * as vscode from 'vscode';
import { MarkdownGenerator } from '../generators/MarkdownGenerator';
import { DirectoryStructure } from '../directoryStructure';
import { DirectoryInfo, FileInfo, ScanOptions } from '../types/fileTypes';
import yaml from 'js-yaml';

jest.mock('vscode');
jest.mock('../directoryStructure');

const mockGenerateYaml = jest.fn<(...args: any[]) => any>();
jest.mock('../generators/YamlGenerator', () => {
    return {
        YamlGenerator: jest.fn().mockImplementation(() => {
            return { generate: mockGenerateYaml };
        })
    };
});

describe('MarkdownGenerator', () => {
    let markdownGenerator: MarkdownGenerator;
    let mockDirectoryStructure: jest.Mocked<DirectoryStructure>;
    let mockConfig: {
        get: jest.Mock<(key: string, defaultValue?: any) => any>;
        has: jest.Mock<any>;
        inspect: jest.Mock<any>;
        update: jest.Mock<any>;
    };

    beforeEach(() => {
        jest.clearAllMocks();

        mockDirectoryStructure = new DirectoryStructure() as jest.Mocked<DirectoryStructure>;
        mockDirectoryStructure.generate.mockImplementation((_dirs: readonly DirectoryInfo[]): string => {
            if (_dirs.length === 0 || !_dirs[0]) return '';
            let output = '# Directory Structure\n';
            output += 'üìÅ test\n';
            if (_dirs[0].files?.length > 0 && _dirs[0].files[0]) {
                output += `  üìÑ ${_dirs[0].files[0].relativePath.split('/').pop() || ''}\n`;
            }
            if (_dirs[0].directories?.size > 0) {
                const subDirName = _dirs[0].directories.keys().next().value as string;
                output += `  üìÅ ${subDirName}\n`;
                const subDir = _dirs[0].directories.get(subDirName);
                if (subDir && subDir.files?.length > 0 && subDir.files[0]) {
                    output += `    üìÑ ${subDir.files[0].relativePath.split('/').pop() || ''}\n`;
                }
            }
            return output;
        });

        mockConfig = {
            get: jest.fn<(key: string, defaultValue?: any) => any>(),
            has: jest.fn(),
            inspect: jest.fn(),
            update: jest.fn(),
        };
        (vscode.workspace.getConfiguration as jest.Mock).mockReturnValue(mockConfig);
        
        mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
            if (key === 'includeDependencies') return false;
            if (key === 'mermaid.maxNodes') return 300;
            if (key === 'prefixText') return '';
            if (key === 'enableCompression') return false;
            return defaultValue;
        });

        mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
            return yaml.dump({ files: [], dependencies: {} });
        });

        markdownGenerator = new MarkdownGenerator(mockDirectoryStructure);
    });

    describe('generate', () => {
        const mockFile: FileInfo = {
            uri: { fsPath: '/test/path/file.txt' } as vscode.Uri,
            relativePath: 'test/path/file.txt',
            content: 'test content',
            size: 1024,
            language: 'plaintext',
            imports: []
        };
        const mockDirectoryInfo: DirectoryInfo = {
            uri: { fsPath: '/test/path' } as vscode.Uri,
            relativePath: 'test/path',
            files: [mockFile],
            directories: new Map(),
            imports: []
        };

        test('Á©∫„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„É™„Çπ„Éà„ÅÆÂ†¥Âêà„ÄÅÁ©∫ÊñáÂ≠óÂàó„ÇíËøî„Åô„Åì„Å®', async () => {
            const result = await markdownGenerator.generate([]);
            expect(result).toBe('');
        });

        describe('ÈÄöÂ∏∏Âá∫Âäõ (includeDependencies: false)', () => {
            beforeEach(() => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return false;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });
            });

            test('Âõ∫ÂÆöÊñáË®Ä„Å™„Åó: ÈÄöÂ∏∏„ÅÆÂá∫Âäõ', async () => {
                const result = await markdownGenerator.generate([mockDirectoryInfo]);
                expect(result).toContain('# Directory Structure');
                expect(result).toContain('üìÅ test');
                expect(result).toContain('üìÑ file.txt');
                expect(result).toContain('# File Contents');
                expect(result).toContain('## test/path/file.txt');
                expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
            });

            test('Âõ∫ÂÆöÊñáË®Ä„ÅÇ„Çä: ÂÖàÈ†≠„Å´ËøΩÂä†', async () => {
                const prefixText = '# Project Overview\nThis is a test project.';
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'prefixText') return prefixText;
                    if (key === 'includeDependencies') return false;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });
                const result = await markdownGenerator.generate([mockDirectoryInfo]);
                expect(result).toMatch(/^# Project Overview\nThis is a test project.\n/);
                expect(result).toContain('# Directory Structure');
                expect(result).toContain('# File Contents');
                expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
            });
        });

        describe('Mermaid„Ç∞„É©„Éï„ÅÇ„Çä (includeDependencies: true)', () => {
            const fileWithImports: FileInfo = {
                ...mockFile,
                relativePath: 'test/path/app.ts',
                imports: ['external:lodash', './utils.ts']
            };
            const utilFile: FileInfo = {
                uri: { fsPath: '/test/path/utils.ts' } as vscode.Uri,
                relativePath: 'test/path/utils.ts',
                content: '// utils',
                size: 50,
                language: 'typescript',
                imports: []
            };
            const dirWithImports: DirectoryInfo = {
                ...mockDirectoryInfo,
                files: [fileWithImports, utilFile]
            };

            beforeEach(() => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });
                
                mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
                    const data = {
                        files: [
                            { relativePath: 'test/path/app.ts', imports: ['external:lodash', './utils.ts'] },
                            { relativePath: 'test/path/utils.ts', imports: [] }
                        ],
                        dependencies: {
                            'test/path/app.ts': ['external:lodash', 'test/path/utils.ts'],
                            'test/path/utils.ts': []
                        }
                    };
                    return yaml.dump(data);
                });
            });

            test('Âõ∫ÂÆöÊñáË®Ä„Å™„Åó: Mermaid„Ç∞„É©„Éï + ÈÄöÂ∏∏„ÅÆÂá∫Âäõ', async () => {
                const result = await markdownGenerator.generate([dirWithImports]);
                expect(result).toContain('<!-- matomeru:auto-graph:start -->');
                expect(result).toContain('flowchart TD');
                // expect(result).toContain('    "test/path/app.ts"'); // Implicitly defined by edge
                // expect(result).toContain('    "external:lodash"'); // This specific assertion might fail as nodes are implicitly defined by edges (already commented out)
                // expect(result).toContain('    "test/path/utils.ts"'); // Implicitly defined by edge
                expect(result).toContain('    "test/path/app.ts" --> "external:lodash"');
                expect(result).toContain('    "test/path/app.ts" --> "test/path/utils.ts"');
                expect(result).toContain('<!-- matomeru:auto-graph:end -->');
                
                const parts = result.split('<!-- matomeru:auto-graph:end -->');
                expect(parts.length).toBe(2);
                expect(parts[1]).toContain('# Directory Structure');
                expect(parts[1]).toContain('# File Contents');
            });

            test('Âõ∫ÂÆöÊñáË®Ä„ÅÇ„Çä: Âõ∫ÂÆöÊñáË®Ä + Mermaid„Ç∞„É©„Éï + ÈÄöÂ∏∏„ÅÆÂá∫Âäõ', async () => {
                const prefixText = '# Project Overview\nThis is a test project.';
                 mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'prefixText') return prefixText;
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });
                const result = await markdownGenerator.generate([dirWithImports]);
                expect(result).toMatch(/^# Project Overview\nThis is a test project.\n(?:\s*\n)?<!-- matomeru:auto-graph:start -->/s);
                
                const contentAfterPrefix = result.substring(prefixText.length + 1); 
                expect(contentAfterPrefix).toContain('<!-- matomeru:auto-graph:start -->');
                expect(contentAfterPrefix).toContain('<!-- matomeru:auto-graph:end -->');
                
                const parts = contentAfterPrefix.split('<!-- matomeru:auto-graph:end -->');
                expect(parts.length).toBe(2);
                expect(parts[1]).toContain('# Directory Structure');
                expect(parts[1]).toContain('# File Contents');
            });

            test('maxNodes „ÇíË∂Ö„Åà„ÇãÂ†¥Âêà„ÅØË≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫„Åô„Çã ‚ÄªgenerateMermaidGraphÂÜÖ„ÅÆ„É≠„Ç∏„ÉÉ„ÇØÂ§âÊõ¥„Å´„Çà„Çä„Åì„ÅÆ„ÉÜ„Çπ„Éà„ÅØÂ§±Êïó„Åô„ÇãÂèØËÉΩÊÄß„ÅÇ„Çä', async () => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 1; 
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });
                
                mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => { 
                     const data = {
                        files: [
                            { relativePath: 'test/path/app.ts', imports: ['./utils.ts'] }, // 1 edge
                            { relativePath: 'test/path/utils.ts', imports: [] }          // 2 nodes
                        ],
                        dependencies: {
                            'test/path/app.ts': ['test/path/utils.ts'],
                            'test/path/utils.ts': []
                        }
                    };
                    return yaml.dump(data);
                });

                const result = await markdownGenerator.generate([dirWithImports]); 
                expect(result).toContain('<!-- matomeru:auto-graph:start -->');
                // generateMermaidGraph „ÅÆ„Éé„Éº„ÉâÊï∞„Ç´„Ç¶„É≥„Éà„Å®Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ„Å´‰æùÂ≠ò„Åô„Çã„Åü„ÇÅ„ÄÅ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂÆåÂÖ®‰∏ÄËá¥„ÅØÈõ£„Åó„ÅÑ„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ
                // Â∞ë„Å™„Åè„Å®„ÇÇ "Truncated" „ÇÑ "limit" „Å®„ÅÑ„Å£„Åü„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåÂê´„Åæ„Çå„Çã„ÅãÁ¢∫Ë™ç
                expect(result).toMatch(/Warning: Mermaid graph truncated/i);
                expect(result).toMatch(/exceeds the configured limit \(1\)/i);
                expect(result).toContain('<!-- matomeru:auto-graph:end -->');
            });

            test('‰æùÂ≠ò„Éá„Éº„Çø„ÅåÁ©∫„ÅÆÂ†¥Âêà„ÄÅMermaid„Ç∞„É©„Éï„ÅØÁîüÊàê„Åï„Çå„Å™„ÅÑ„Åì„Å®', async () => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });

                // YamlGenerator„ÅåÁ©∫„ÅÆdependencies„ÇíËøî„Åô„Çà„ÅÜ„Å´„É¢„ÉÉ„ÇØ„ÇíË®≠ÂÆö
                mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
                    const data = {
                        files: [ // files„ÅØ„ÉÄ„Éü„Éº„Éá„Éº„Çø„Åß„ÇÇËâØ„ÅÑ„Åå„ÄÅÊßãÈÄ†„ÅØÁ∂≠ÊåÅ
                            { relativePath: 'test/path/app.ts', imports: [] },
                            { relativePath: 'test/path/utils.ts', imports: [] }
                        ],
                        dependencies: {} // „Åì„Åì„ÇíÁ©∫„Å´„Åô„Çã
                    };
                    return yaml.dump(data);
                });

                const result = await markdownGenerator.generate([dirWithImports]); // dirWithImports „ÅØÊó¢Â≠ò„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÇíÂà©Áî®

                // Mermaid„Ç∞„É©„Éï„ÅÆÈñãÂßã„ÉªÁµÇ‰∫Ü„Ç≥„É°„É≥„Éà„ÅåÂê´„Åæ„Çå„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
                expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
                expect(result).not.toContain('flowchart TD');
                expect(result).not.toContain('<!-- matomeru:auto-graph:end -->');

                // ÈÄöÂ∏∏„ÅÆ„Éï„Ç°„Ç§„É´„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅØÂê´„Åæ„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
                expect(result).toContain('# Directory Structure');
                expect(result).toContain('# File Contents');
                expect(result).toContain('## test/path/app.ts'); // dirWithImports„ÅÆ„Éï„Ç°„Ç§„É´
            });

            test('‰∏ÄÈÉ®„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Åø‰æùÂ≠òÈñ¢‰øÇ„ÇíÊåÅ„Å§Â†¥Âêà„ÄÅÊ≠£„Åó„Åè„Ç∞„É©„Éï„ÅåÁîüÊàê„Åï„Çå„Çã„Åì„Å®', async () => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });

                mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
                    const data = {
                        files: [
                            { relativePath: 'test/app.js', imports: ['external:moment', './utils.js'] },
                            { relativePath: 'test/utils.js', imports: [] }, // utils.js „ÅØ‰æùÂ≠ò„Å™„Åó
                            { relativePath: 'test/another.js', imports: [] } // another.js „ÇÇ‰æùÂ≠ò„Å™„Åó
                        ],
                        dependencies: {
                            'test/app.js': ['external:moment', 'test/utils.js'],
                            // 'test/utils.js': [] // dependencies „Å´„ÅØÁ©∫„ÅÆÈÖçÂàó„ÅØÂê´„ÇÅ„Å™„ÅÑ„Åì„Å®„ÅåÂ§ö„ÅÑ
                            // 'test/another.js': []
                        }
                    };
                    return yaml.dump(data);
                });

                const dirWithPartialDeps: DirectoryInfo = {
                    ...mockDirectoryInfo, // Âü∫Êú¨ÊßãÈÄ†„ÅØÊó¢Â≠ò„ÅÆ„ÇÇ„ÅÆ„ÇíÊµÅÁî®
                    files: [
                        { ...mockFile, relativePath: 'test/app.js', imports: ['external:moment', './utils.js'] },
                        { ...mockFile, relativePath: 'test/utils.js', content: '// Utility functions', imports: [] },
                        { ...mockFile, relativePath: 'test/another.js', content: '// Another file', imports: [] }
                    ]
                };

                const result = await markdownGenerator.generate([dirWithPartialDeps]);

                expect(result).toContain('<!-- matomeru:auto-graph:start -->');
                expect(result).toContain('flowchart TD');
                expect(result).toContain('    "test/app.js" --> "external:moment"');
                expect(result).toContain('    "test/app.js" --> "test/utils.js"');
                // utils.js „ÇÑ another.js „Åã„Çâ„ÅÆ‰æùÂ≠ò„Åå„Å™„ÅÑ„Åü„ÇÅ„ÄÅ„Åù„Çå„Çâ„ÇíËµ∑ÁÇπ„Å®„Åô„Çã„Ç®„ÉÉ„Ç∏„ÅØÂ≠òÂú®„Åó„Å™„ÅÑ
                expect(result).not.toContain('"test/utils.js" -->');
                expect(result).not.toContain('"test/another.js" -->');
                expect(result).toContain('<!-- matomeru:auto-graph:end -->');

                expect(result).toContain('## test/app.js');
                expect(result).toContain('## test/utils.js');
                expect(result).toContain('## test/another.js');
            });

            test('„Éï„Ç°„Ç§„É´„Éë„Çπ„Å´ÂºïÁî®Á¨¶„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Ç®„Çπ„Ç±„Éº„Éó„Åï„Çå„Å¶Mermaid„Ç∞„É©„Éï„Å´Âê´„Åæ„Çå„Çã', async () => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });

                mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
                    const data = {
                        files: [
                            { relativePath: 'test/"weird".ts', imports: ['./utils.ts'] },
                            { relativePath: 'test/utils.ts', imports: [] }
                        ],
                        dependencies: {
                            'test/"weird".ts': ['test/utils.ts'],
                            'test/utils.ts': []
                        }
                    };
                    return yaml.dump(data);
                });

                const dirWithQuote: DirectoryInfo = {
                    ...mockDirectoryInfo,
                    files: [
                        { ...mockFile, relativePath: 'test/"weird".ts', imports: ['./utils.ts'] },
                        { ...mockFile, relativePath: 'test/utils.ts', imports: [] }
                    ]
                };

                const result = await markdownGenerator.generate([dirWithQuote]);

                expect(result).toContain('<!-- matomeru:auto-graph:start -->');
                expect(result).toContain('flowchart TD');
                expect(result).toContain('    "test/\\"weird\\".ts" --> "test/utils.ts"');
                expect(result).toContain('<!-- matomeru:auto-graph:end -->');
            });

            describe('maxNodesÂà∂Èôê„ÅÆ„ÉÜ„Çπ„Éà', () => {
                const baseDirWithImports: DirectoryInfo = { // „Åì„ÅÆ„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„ÉàÂÜÖ„ÅßÂÖ±ÈÄö„Åß‰Ωø„Åà„Çã„Éá„Éº„Çø
                    ...mockDirectoryInfo,
                    files: [
                        { ...mockFile, relativePath: 'test/a.js', imports: ['./b.js', './c.js'] }, // a -> b, a -> c (3 nodes, 2 edges initially)
                        { ...mockFile, relativePath: 'test/b.js', imports: ['./d.js'] },             // b -> d (d is new, 4 nodes, 3 edges)
                        { ...mockFile, relativePath: 'test/c.js', imports: ['./d.js', './e.js'] },   // c -> d, c -> e (e is new, 5 nodes, 5 edges)
                        { ...mockFile, relativePath: 'test/d.js', imports: [] },
                        { ...mockFile, relativePath: 'test/e.js', imports: ['./a.js'] }              // e -> a (cycle, 5 nodes, 6 edges)
                    ]
                };
                const correspondingDependencies = {
                    'test/a.js': ['test/b.js', 'test/c.js'],
                    'test/b.js': ['test/d.js'],
                    'test/c.js': ['test/d.js', 'test/e.js'],
                    'test/e.js': ['test/a.js'] 
                    // d.js „ÅØ‰æùÂ≠òÂÖà„Åå„Å™„ÅÑ„ÅÆ„ÅßÁúÅÁï•
                }; // 5 nodes (a,b,c,d,e), 6 edges

                beforeEach(() => { // „Åì„ÅÆdescribe„Éñ„É≠„ÉÉ„ÇØ„ÅÆÂêÑ„ÉÜ„Çπ„Éà„ÅÆÂâç„Å´ÂÖ±ÈÄö„ÅÆ„É¢„ÉÉ„ÇØË®≠ÂÆö
                    mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                        if (key === 'includeDependencies') return true;
                        // maxNodes „ÅØÂêÑ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„Åß‰∏äÊõ∏„Åç„Åô„Çã
                        if (key === 'prefixText') return '';
                        if (key === 'enableCompression') return false;
                        return defaultValue;
                    });
                    mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
                        const data = {
                            files: baseDirWithImports.files.map(f => ({ relativePath: f.relativePath, imports: f.imports })),
                            dependencies: correspondingDependencies
                        };
                        return yaml.dump(data);
                    });
                });

                test('„Éé„Éº„ÉâÊï∞„ÅåmaxNodes„Å®‰∏ÄËá¥„Åô„ÇãÂ†¥Âêà„ÄÅ„Ç∞„É©„Éï„ÅØÂÆåÂÖ®„Å´Ë°®Á§∫„Åï„Çå„Çã', async () => {
                    mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                        if (key === 'includeDependencies') return true;
                        if (key === 'mermaid.maxNodes') return 5; // „Éé„Éº„ÉâÊï∞„Å®‰∏ÄËá¥
                        if (key === 'prefixText') return '';
                        if (key === 'enableCompression') return false;
                        return defaultValue;
                    });
                    const result = await markdownGenerator.generate([baseDirWithImports]);
                    expect(result).toContain('flowchart TD');
                    expect(result).toContain('"test/a.js"'); // „Éé„Éº„Éâ„ÅÆÂ≠òÂú®Á¢∫Ë™ç
                    expect(result).toContain('"test/e.js"');
                    expect(result).toContain('    "test/e.js" --> "test/a.js"'); // „Ç®„ÉÉ„Ç∏„ÅÆÂ≠òÂú®Á¢∫Ë™ç
                    expect(result).not.toMatch(/Warning: Mermaid graph truncated/i);
                });

                test('„Éé„Éº„ÉâÊï∞„ÅåmaxNodes„Çí1„Å§Ë∂Ö„Åà„ÇãÂ†¥Âêà (Êó¢Â≠ò„ÅÆmaxNodes:1„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„Å®ÂêåÊßò„ÅÆË∂£Êó®)', async () => {
                    mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                        if (key === 'includeDependencies') return true;
                        if (key === 'mermaid.maxNodes') return 4; // „Éé„Éº„ÉâÊï∞5„Å´ÂØæ„Åó„Å¶4
                        if (key === 'prefixText') return '';
                        if (key === 'enableCompression') return false;
                        return defaultValue;
                    });
                    const result = await markdownGenerator.generate([baseDirWithImports]);
                    expect(result).toMatch(/Warning: Mermaid graph truncated/i);
                    expect(result).toMatch(/exceeds the configured limit \(4\)/i);
                     // „Ç∞„É©„Éï„ÅÆÂÜÖÂÆπËá™‰Ωì„ÇÇ„ÅÇ„ÇãÁ®ãÂ∫¶„ÅØÊèèÁîª„Åï„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™çÔºàÁúÅÁï•„ÅÆ‰ªïÊñπ„Å´„Çà„ÇãÔºâ
                    expect(result).toContain('flowchart TD');
                });
                
                test('„Éé„Éº„ÉâÊï∞„ÅåmaxNodes„ÇíÂ§ßÂπÖ„Å´Ë∂Ö„Åà„ÇãÂ†¥Âêà„ÄÅ„Ç∞„É©„Éï„ÅØÁúÅÁï•„Åï„ÇåË≠¶Âëä„ÅåË°®Á§∫„Åï„Çå„Çã', async () => {
                    mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                        if (key === 'includeDependencies') return true;
                        if (key === 'mermaid.maxNodes') return 2; // „Éé„Éº„ÉâÊï∞5„Å´ÂØæ„Åó„Å¶2
                        if (key === 'prefixText') return '';
                        if (key === 'enableCompression') return false;
                        return defaultValue;
                    });
                    const result = await markdownGenerator.generate([baseDirWithImports]);
                    expect(result).toMatch(/Warning: Mermaid graph truncated/i);
                    expect(result).toMatch(/exceeds the configured limit \(2\)/i);
                    expect(result).toContain('flowchart TD'); // subgraph Warning „ÇÇ flowchart TD „ÅÆ‰∏ÄÈÉ®
                });

                // ÂÖÉ„ÅÆmaxNodes„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÇÇÊÆã„Åô„Åã„ÄÅ„Åì„ÅÆÊñ∞„Åó„ÅÑ„Çπ„Ç§„Éº„Éà„Å´Áµ±Âêà„Åô„Çã„ÅãÊ§úË®é„Åß„Åç„Åæ„Åô„ÄÇ
                // „Åì„Åì„Åß„ÅØÊñ∞„Åó„ÅÑ„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà„Å®„Åó„Å¶ÂàÜÈõ¢„Åó„Åæ„Åó„Åü„ÄÇ
            });

            test('ÂÆüÈöõ„ÅÆJS„Éï„Ç°„Ç§„É´Èñì„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÇíÊ®°„Åó„Åü„Ç±„Éº„Çπ„Åß„Ç∞„É©„Éï„ÅåÊ≠£„Åó„ÅèÁîüÊàê„Åï„Çå„Çã', async () => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });

                // scanDependencies„ÅåËøî„Åô„Åß„ÅÇ„Çç„ÅÜ„Éá„Éº„ÇøÊßãÈÄ†„ÇíYamlGenerator„ÅÆ„É¢„ÉÉ„ÇØ„ÅßÂÜçÁèæ
                mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
                    const data = {
                        files: [ // FileInfo.imports „ÇíÊ®°ÂÄ£
                            { relativePath: 'src/app.js', imports: ['external:moment', './utils.js'], content: 'import moment from "moment";\nimport { helper } from "./utils.js";' },
                            { relativePath: 'src/utils.js', imports: [], content: 'export const helper = () => {};' }
                        ],
                        dependencies: { // ‰∏äË®ò imports „Å´Âü∫„Å•„Åè‰æùÂ≠òÈñ¢‰øÇ
                            'src/app.js': ['external:moment', 'src/utils.js']
                            // 'src/utils.js': [] // ‰æùÂ≠ò„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç≠„ÉºËá™‰Ωì„Åå„Å™„ÅÑ„Åì„Å®„ÅåÂ§ö„ÅÑ
                        }
                    };
                    return yaml.dump(data);
                });
                
                // MarkdownGenerator„Å´Ê∏°„ÅôDirectoryInfo„Éá„Éº„Çø„ÄÇ„Åì„Åì„Åß„ÅÆFileInfo.imports„ÅØÂÆüÈöõ„Å´„ÅØ‰Ωø„Çè„Çå„Å™„ÅÑ„Åå„ÄÅÊßãÈÄ†„Å®„Åó„Å¶Ê∏°„Åô„ÄÇ
                const jsDir: DirectoryInfo = {
                    uri: { fsPath: '/project/src' } as vscode.Uri,
                    relativePath: 'src',
                    files: [
                        { 
                            uri: { fsPath: '/project/src/app.js' } as vscode.Uri,
                            relativePath: 'src/app.js', 
                            content: 'import moment from "moment";\nimport { helper } from "./utils.js";', 
                            language: 'javascript', 
                            size: 100,
                            imports: ['external:moment', './utils.js'] // scanDependencies„ÅåË®≠ÂÆö„Åô„Çã„Åß„ÅÇ„Çç„ÅÜÂÄ§
                        },
                        { 
                            uri: { fsPath: '/project/src/utils.js' } as vscode.Uri,
                            relativePath: 'src/utils.js', 
                            content: 'export const helper = () => {};', 
                            language: 'javascript', 
                            size: 50,
                            imports: [] // scanDependencies„ÅåË®≠ÂÆö„Åô„Çã„Åß„ÅÇ„Çç„ÅÜÂÄ§
                        }
                    ],
                    directories: new Map()
                };

                const result = await markdownGenerator.generate([jsDir]);

                expect(result).toContain('<!-- matomeru:auto-graph:start -->');
                expect(result).toContain('flowchart TD');
                expect(result).toContain('    "src/app.js" --> "external:moment"');
                expect(result).toContain('    "src/app.js" --> "src/utils.js"');
                expect(result).not.toContain('"src/utils.js" -->'); // utils.js„Åã„Çâ„ÅÆ‰æùÂ≠ò„ÅØ„Å™„ÅÑ
                expect(result).toContain('<!-- matomeru:auto-graph:end -->');

                // „Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÅÆË°®Á§∫„ÇÇÁ¢∫Ë™ç
                expect(result).toContain('## src/app.js');
                expect(result).toContain('import moment from "moment";');
                expect(result).toContain('## src/utils.js');
                expect(result).toContain('export const helper = () => {};');
            });

            test('Âæ™Áí∞‰æùÂ≠ò„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅË≠¶Âëä„Ç≥„É°„É≥„Éà„ÅåËøΩÂä†„Åï„Çå„Çã', async () => {
                mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                    if (key === 'includeDependencies') return true;
                    if (key === 'mermaid.maxNodes') return 300;
                    if (key === 'prefixText') return '';
                    if (key === 'enableCompression') return false;
                    return defaultValue;
                });

                mockGenerateYaml.mockImplementation((_directoriesInfo: DirectoryInfo[], _options: ScanOptions): string => {
                    const data = {
                        files: [
                            { relativePath: 'test/a.ts', imports: ['./b.ts'] },
                            { relativePath: 'test/b.ts', imports: ['./c.ts'] },
                            { relativePath: 'test/c.ts', imports: ['./a.ts'] }
                        ],
                        dependencies: {
                            'test/a.ts': ['test/b.ts'],
                            'test/b.ts': ['test/c.ts'],
                            'test/c.ts': ['test/a.ts']
                        }
                    };
                    return yaml.dump(data);
                });

                const dirWithCycle: DirectoryInfo = {
                    ...mockDirectoryInfo,
                    files: [
                        { ...mockFile, relativePath: 'test/a.ts', imports: ['./b.ts'] },
                        { ...mockFile, relativePath: 'test/b.ts', imports: ['./c.ts'] },
                        { ...mockFile, relativePath: 'test/c.ts', imports: ['./a.ts'] }
                    ]
                };

                const result = await markdownGenerator.generate([dirWithCycle]);

                expect(result).toContain('flowchart TD');
                expect(result).toMatch(/%% Warning: Circular dependencies detected/);
            });
        });

        test('„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅåÈÅ©Âàá„Å´„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åï„Çå„Çã„Åì„Å®', async () => {
            mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
                if (key === 'includeDependencies') return false;
                if (key === 'mermaid.maxNodes') return 300;
                if (key === 'prefixText') return '';
                if (key === 'enableCompression') return false;
                return defaultValue;
            });
            const filesToTest = [
                { size: 500, expected: '500 B' },
                { size: 1024, expected: '1 KB' },
                { size: 1536, expected: '1.5 KB' },
                { size: 1048576, expected: '1 MB' },
                { size: 1073741824, expected: '1 GB' }
            ];

            for (const { size, expected } of filesToTest) {
                const directoryInfo: DirectoryInfo = {
                    ...mockDirectoryInfo,
                    files: [{
                        ...mockDirectoryInfo.files[0],
                        size
                    }]
                };
                mockDirectoryStructure.generate.mockImplementation((_dirs) => '# Directory Structure\nüìÅ test\n  üìÑ file.txt\n');
                const result = await markdownGenerator.generate([directoryInfo]);
                expect(result).toContain(`Size: ${expected}`);
                expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
            }
        });
    });

    it('Âçò‰∏Ä„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂê´„ÇÄ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÊ≠£„Åó„ÅèÂá¶ÁêÜ„Åô„Çã', async () => {
        mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
            if (key === 'includeDependencies') return false;
            if (key === 'mermaid.maxNodes') return 300;
            if (key === 'prefixText') return '';
            if (key === 'enableCompression') return false;
            return defaultValue; 
        });
        mockGenerateYaml.mockResolvedValue(yaml.dump({ files: [], dependencies: {} }));

        const dir: DirectoryInfo = {
            uri: vscode.Uri.file('/test'),
            relativePath: 'test',
            files: [
                {
                    uri: vscode.Uri.file('/test/file1.ts'),
                    relativePath: 'test/file1.ts',
                    content: 'console.log("Hello");',
                    language: 'typescript',
                    size: 100,
                    imports: []
                }
            ],
            directories: new Map(),
            imports: []
        };

        mockDirectoryStructure.generate.mockReturnValue('# Directory Structure\nüìÅ test\n  üìÑ file1.ts\n');

        const result = await markdownGenerator.generate([dir]);
        
        expect(result).toContain('# Directory Structure');
        expect(result).toContain('üìÅ test');
        expect(result).toContain('üìÑ file1.ts');
        expect(result).toContain('# File Contents');
        expect(result).toContain('## test/file1.ts');
        expect(result).toContain('- Size: 100 B');
        expect(result).toContain('- Language: typescript');
        expect(result).toContain('```typescript');
        expect(result).toContain('console.log("Hello");');
        expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
    });

    it('Ë§áÊï∞„ÅÆ„Éï„Ç°„Ç§„É´„Å®„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÊ≠£„Åó„ÅèÂá¶ÁêÜ„Åô„Çã', async () => {
        mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
            if (key === 'includeDependencies') return false;
            if (key === 'mermaid.maxNodes') return 300;
            if (key === 'prefixText') return '';
            if (key === 'enableCompression') return false;
            return defaultValue;
        });
        mockGenerateYaml.mockResolvedValue(yaml.dump({ files: [], dependencies: {} }));

        const subDirFile: FileInfo = {
            uri: vscode.Uri.file('/test/src/main.ts'),
            relativePath: 'test/src/main.ts',
            content: 'export const main = () => {};',
            language: 'typescript',
            size: 200,
            imports: []
        };
        const subDir: DirectoryInfo = {
            uri: vscode.Uri.file('/test/src'),
            relativePath: 'test/src',
            files: [subDirFile],
            directories: new Map(),
            imports: []
        };
        const rootFile: FileInfo = {
            uri: vscode.Uri.file('/test/README.md'),
            relativePath: 'test/README.md',
            content: '# Test Project',
            language: 'markdown',
            size: 100,
            imports: []
        };
        const dir: DirectoryInfo = {
            uri: vscode.Uri.file('/test'),
            relativePath: 'test',
            files: [rootFile],
            directories: new Map([['src', subDir]]),
            imports: []
        };

        mockDirectoryStructure.generate.mockReturnValue('# Directory Structure\nüìÅ test\n  üìÑ README.md\n  üìÅ src\n    üìÑ main.ts\n');
        const result = await markdownGenerator.generate([dir]);
        
        expect(result).toContain('# Directory Structure');
        expect(result).toContain('üìÅ test');
        expect(result).toContain('üìÑ README.md');
        expect(result).toContain('üìÅ src');
        expect(result).toContain('üìÑ main.ts');
        expect(result).toContain('# File Contents');
        expect(result).toContain('## test/README.md');
        expect(result).toContain('```markdown');
        expect(result).toContain('# Test Project');
        expect(result).toContain('## test/src/main.ts');
        expect(result).toContain('```typescript');
        expect(result).toContain('export const main = () => {};');
        expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
    });

    it('„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÇíÈÅ©Âàá„Å´„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åô„Çã', async () => {
        mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
            if (key === 'includeDependencies') return false;
            if (key === 'mermaid.maxNodes') return 300;
            if (key === 'prefixText') return '';
            if (key === 'enableCompression') return false;
            return defaultValue;
        });
        mockGenerateYaml.mockResolvedValue(yaml.dump({ files: [], dependencies: {} }));
        const dir: DirectoryInfo = {
            uri: vscode.Uri.file('/test'),
            relativePath: 'test',
            files: [
                {
                    uri: vscode.Uri.file('/test/small.txt'),
                    relativePath: 'test/small.txt',
                    content: 'Small file',
                    language: 'plaintext',
                    size: 512,
                    imports: []
                },
                {
                    uri: vscode.Uri.file('/test/medium.txt'),
                    relativePath: 'test/medium.txt',
                    content: 'Medium file',
                    language: 'plaintext',
                    size: 1024 * 100,
                    imports: []
                },
                {
                    uri: vscode.Uri.file('/test/large.txt'),
                    relativePath: 'test/large.txt',
                    content: 'Large file',
                    language: 'plaintext',
                    size: 1024 * 1024 * 2,
                    imports: []
                }
            ],
            directories: new Map(),
            imports: []
        };
        mockDirectoryStructure.generate.mockReturnValue('# Directory Structure\nüìÅ test\n  üìÑ small.txt\n  üìÑ medium.txt\n  üìÑ large.txt\n');
        const result = await markdownGenerator.generate([dir]);
        
        expect(result).toContain('- Size: 512 B');
        expect(result).toContain('- Size: 100 KB');
        expect(result).toContain('- Size: 2 MB');
        expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
    });

    it('„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„Åå1024„ÅÆÂÄçÊï∞„ÅÆÂ†¥Âêà„ÄÅÂ∞èÊï∞ÁÇπ‰ª•‰∏ã„ÇíË°®Á§∫„Åó„Å™„ÅÑ', async () => {
        mockConfig.get.mockImplementation((key: string, defaultValue?: any): any => {
            if (key === 'includeDependencies') return false;
            if (key === 'mermaid.maxNodes') return 300;
            if (key === 'prefixText') return '';
            if (key === 'enableCompression') return false;
            return defaultValue;
        });
        mockGenerateYaml.mockResolvedValue(yaml.dump({ files: [], dependencies: {} }));
        const dir: DirectoryInfo = {
            uri: vscode.Uri.file('/test'),
            relativePath: 'test',
            files: [
                {
                    uri: vscode.Uri.file('/test/exact.txt'),
                    relativePath: 'test/exact.txt',
                    content: 'Exact size file',
                    language: 'plaintext',
                    size: 1024,
                    imports: []
                },
                {
                    uri: vscode.Uri.file('/test/exact_mb.txt'),
                    relativePath: 'test/exact_mb.txt',
                    content: 'Exact MB size file',
                    language: 'plaintext',
                    size: 1024 * 1024,
                    imports: []
                }
            ],
            directories: new Map(),
            imports: []
        };
        mockDirectoryStructure.generate.mockReturnValue('# Directory Structure\nüìÅ test\n  üìÑ exact.txt\n  üìÑ exact_mb.txt\n');
        const result = await markdownGenerator.generate([dir]);
        
        expect(result).toContain('- Size: 1 KB');
        expect(result).toContain('- Size: 1 MB');
        expect(result).not.toContain('<!-- matomeru:auto-graph:start -->');
    });
}); 